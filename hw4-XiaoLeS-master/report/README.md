# 作業 4 報告

> 學生：孫汶琳
>
> 學號：0680707

# 作業架構介紹

本次作業目的在於針對前次作業所建之Abstract Syntax Tree (AST)來做語意分析 (Semantic Analysis)，以下將本次作業的實作分為三個部分（任務）來作說明，其中包含：Symbol Table之操作、節點(tree node)間之資料傳遞以及語意檢查。
由於使用VP pattern的關係，AST樹之遍歷(traverse)方式與前次作業的ASTDumper相似，概念上就是從根節點(root, program node)開始，依深度優先的方式做整棵樹的遍歷，實作上我們將一個節點的工作階段分成探訪子節點(child node)前、後兩大階段；其中每一個階段都有所需之任務，任務細節會因節點種類不同而有所區別，種類上可以分為建立範圍(Scope)的節點、有代表不同資料型態的節點(Expression)等等，將在接下來的篇幅做詳細的說明。

首先針對Symbol Table(以下簡稱ST)之操作部分來做說明，實作上我們定義了一個SymbolManager來對所有的ST做操作，每個ST實際上代表著一個scope，其中ST由零到數個entry所組成，而scope會影響entry的存續。
ST的操作可分為建立ST、查看ST、修改ST三種工作。
- 建立/刪除ST：這個任務是在遍歷到會建立scope的節點時所執行，主要執行階段在探訪子節點前，而會建立scope的節點有像是ProgramNode、FuntionNode和CompoundStatementNode等。
- 查看ST：這個任務主要是用來協助語意分析任務之執行，用來存取和檢查ST上的entry資訊。
- 修改ST：這個任務包含entry的建立，在執行到像是ProgramNode、VariableNode和FunctionNode等用來宣告特定程式元素的節點時所需執行的，主要執行階段在探訪子節點前。

再來是節點間資料傳遞的部分，這些資料主要用於語意分析，而節點間會傳遞的資料分為父節點到子節點、子節點到父節點兩個方向。
由於而語意分析主要實作於結束子節點探訪後，因此會以子節點到父節點這個方向的傳遞為主。
其中，最主要的資料包含節點資料型態和錯誤偵測。
節點資料型態用於輔助語意判斷，透過定義子節點的代表資料型態，父節點在做和子節點相關之語意判斷時，不需要重新遍歷子節點，舉例而言，考慮`C = A + B[10]`的這個例子，其中AssignmentNode在判斷VariableReferenceNode C和BinaryOperatorNode(+)兩者型態是否相等時，不需要再下到BinaryOperatorNode中來檢查A和B兩個的資料型態，而是在先前遍歷完A和B[10]兩個節點回來後，就先將型態判斷結果存在節點上，如此在前述例子中判斷型態時便可直接取來使用。
此外，錯誤偵測部分的機制也有異曲同工之妙，節點錯誤檢查主要應用於當父節點的語意分析需要來自子節點的資訊之情況，因此需要先檢查子節點是否有錯誤發生。
```
C = A + B[10] ：
		         =
		       / |
		      C  +
		       / |
		      A  B 
```
接續前述的`C = A + B[10]`的例子，若在遍歷子節點到B[10]時發現B[10]有dimension過大的錯誤，將會透過一個bool[6]的陣列在子節點記錄此次錯誤的發生種類（bool陣列長度為6，作為6種Group Error發生的記錄），而子節點遍歷完成回來後，該節點需將其子節點所發生的錯誤的聯集記錄到本身的bool[6]陣列，如此一來，BinaryOperatorNode(+)在做型別判斷前，即可以本身的bool[6]錯誤紀錄來做錯誤發生的檢測，若以型別判斷為例，如有任何的錯誤在子節點發生，就不需要繼續進行檢測了。

最後是語意檢查的部分，本次語意的檢查分佈在探訪子節點前後兩個階段。
在探訪子節點前主要是做重複宣告的判斷，在沒有錯誤的情況下，這個階段主要的工作在於scope和entry的建立。
而其中entry的建立若是將重複宣告的檢查放在探訪子節點後並不適合，因為table的資訊可能會在其他節點上被使用，若是同個ST上有兩個名稱相同的entry，則會造成其他語意檢查的不清楚，簡單來說，與其在使用時檢查entry的正確性，不如在entry加入ST前就先檢查其合理性。
另一方面，在探訪子節點後的語意判斷工作相對多出許多，因為此時的ST和節點資訊相對探訪前完善，因此較為適合做較複雜的語意檢查。
本次作業中主要的語意檢查也幾乎都放在這階段，我們將這些語意檢查分為六個group，若是子節點上有發生同樣group的錯誤，則在父節點上這個group的錯誤檢測就需要先略過（不過這次作業中，大部分的情況是子節點有任意error時，父節點的檢查就先忽略）。舉例來說，不管是前面提到陣列使用的dimension大小超過所宣告之數量，還是BinaryOperator(+)在判斷兩個運算元的資料型態是否能夠相互運算，這些資料需求量相對較大的錯誤檢查都會是在這個階段來做處理。


# 作業困難簡述
這次的作業在剛開始寫時門檻沒有上次的高，一個原因可能是因為對於VP的模式熟悉了，另一個原因是VP太方便了，每個節點要處理的工作可以很集中的處理和參照，所以和上次作業一樣，先做了幾個節點之後後面就會有飛速的進展。
遇到比較大的問題主要是在資料型態的部分有一些我沒用過的C++語法加入像是shared_ptr和unique_ptr等等，一開始還是把它當作普通的、我所熟知的資料型態來做處理，遇到error，像是要把unique_ptr轉shared_ptr時，就去stackoverflow上找解法，但也因為這樣才會被像`std::move`這種行為未知的解法纏身，不太應該...。


# 小心得
這兩次寫作業都讓我有種我跟Ｃ＋＋很不熟的感覺，讓我以後都不敢說我當過程式設計課助教了。
不過也很高興藉由這兩次的作業開了我的眼界！
讓我意外的是這次作業比上次作業寫起來順遂很多，上次的開頭真的太煎熬了。
其實寫到後半段比較有心力多想些雜七雜八的時候，我就會想以後如果使用compiler遇到什麼bug我都可以以更...慈悲（？）的心態去面對了，因為自己寫了就知道，有人願意開發compiler來給大家用真的是相當令人感動，而且很有勇氣！

另外就是，我之前都沒有想到其實現在應該可以用WSL在windows上跑docker了，這樣如果有人用windows開發就不用自己再裝個虛擬機，或許下次作業我試完可以整理一下步驟丟到instructionXD
